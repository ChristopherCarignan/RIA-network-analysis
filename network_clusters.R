# Determine the number of clusters generated by the network model from each of 100 different random seeds
network.clusters <- function(RIA.table) {
  cluster.table <- c()
  myrow <- 1
  
  plist <- levels(RIA.table$participant) # List of all participant names
  
  for (vowel in c('a','e','o')){
    for (myseed in 1:100){
      set.seed(myseed)
      
      subdata <- RIA.table[RIA.table$vowel==vowel,] # Get the unique data
      
      dists <- matrix(nrow=length(plist), ncol=length(plist)) # Preallocate similarity matrix
      
      for (x in 1:length(plist)){
        # Get participant 1
        p1    <- plist[x]
        p1dat <- subdata$coeffs[subdata$participant==p1]
        
        for (y in 1:length(plist)){
          # Get participant 2
          p2    <- plist[y]
          p2dat <- subdata$coeffs[subdata$participant==p2]
          
          # Euclidean distance between participants 1 and 2
          dist  <- sqrt( (p1dat[1] - p2dat[1])^2 + (p1dat[2] - p2dat[2])^2 + (p1dat[3] - p2dat[3])^2 )
          
          # Distance-based similarity score
          dists[x,y] <- 1/(1+dist)
        }
      }
      
      # Scale the similarity matrix: 0-1
      sim.mats <- (dists - min(dists)) / (1 - min(dists))
      
      # Create a blank network graph for the spinglass algorithm
      graph1 <- qgraph(sim.mats, layout="groups", graph="cor", sampleSize=length(plist), DoNotPlot=T)
      
      g   <- as.igraph(graph1, attributes=T) # Convert to igraph
      sgc <- spinglass.community(g) # Perform spinglass algorithm to get groupings/clusters
      
      # Get groupings/clusters
      clusters  <- length(sgc$csize)
      cluster.table$seed[myrow]      <- myseed
      cluster.table$vowel[myrow]     <- vowel
      cluster.table$clusters[myrow]  <- clusters
      
      myrow <- myrow + 1 # Iterate for next seed
    }
  }
  
  cluster.table <- as.data.frame(cluster.table)
  cluster.table$vowel <- as.factor(cluster.table$vowel)
  cluster.table$clusters <- as.factor(cluster.table$clusters)
  
  return(cluster.table)
}